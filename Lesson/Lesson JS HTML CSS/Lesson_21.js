'use strict'

// hoisting
// это всплытие и объявление переменых в том числе вверх области виидмости. нужно помнить какая область видимости у нас

sayHello();

function sayHello() {
  console.log('Hello From Declaration');
}
// данная функция может быть вызвана(объявлена) выше самой функции

// --------------------------

// sayHello2();

const sayHello2 = function () {
  console.log('Hello From Expression');
}
// const sayHello2 = function () данная функция без указания имени перед скобками, являетс анонимной. но наименование это фукции не имеет смысла, так как она вичесляется и присваивается её результ const sayHello2
// Данная функция не может быть вызвана(объявлена) выше самой функции

// ---------------------------

// sayHello3();

const sayHello3 = () => {
  console.log('Hello From Lambda Expression');
}
// у данной фунции будет такая же ошибка при вызове её выше

sayHello();
sayHello2();
sayHello3();

// -----------------------------------
// пример с var  как нельзя делать
// результатом будет undefined, так как переменная определена, но значение присваивается ей но строчке ниже

console.log(z);
var z = '1';

// для правильного отображения лучше делать так 

var x;
console.log(x); // но так всё равно отобразиться undefined
x = '3';
console.log(x);
// -----------------

var v = 3;

function printV() {
  console.log(v);

  var v = '5';
}
// в данном случае тоже будет undefined, почему так происходит?
// дело в том когда мы объявили v в глобальной области видимости в которой она var v = 3;, но мы также объявили её в локальной области функции переменную, которая никак не относится к внешней, мы объявили её  var v = '5';, но объявили мы ее ниже чем console.log(v); и по итогу по hoisting  мы получили следующее
// function printV() {
//   var v;
//   console.log(v);
//   v = '5';
// }
printV();

// Пример с let(не важно let или const)=====================
// так как с точки зрения hoisting они работают одинаково

let w = '8';

function printW() {
  console.log(w);

  let w = '6';
}

printW();